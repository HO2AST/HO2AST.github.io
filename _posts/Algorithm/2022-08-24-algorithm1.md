---
title:  "시간복잡도"

categories:

- Algorithm
tags:
- [Algorithm, TimeComplex]

toc: true
toc_sticky: false

## date: 2022-08-24
last_modified_at: 2022-08-24
---

<aside>
💡 본 포스트는 한국외대 컴퓨터공학부 신찬수 교수님의 자료구조 수업내용과 자료를 참조하여 작성되었습니다.

</aside>

---

## 알고리즘의 시간복잡도

- 가상 컴퓨터에서 가상언어로 작성된 가상코드(Pseudo Code)를 실행한다고 가정한다.
- 특정 입력에 대해 수행되는 알고리즘의 기본연산(primitive operation)의 횟수로 수행시간을 정의한다.
    
    > 기본연산의 종류
    - 대입연산 (=)
    - 산술연산 (+, -, *, /)
    - 비교연산 (>, ≥, <, ≤, ==, ≠)
    - 논리연산 (AND, OR, NOT)
    - 비트연산 (bit-AND, bit-OR, bit-NOT, bit-XOR, <<, >>)
    > 
- 하지만 입력의 종류가 무한하기 때문에 현실적으로 평균을 구하는것은 불가능하기 때문에 최악의
입력(worst-case input)을 가정하여 알고리즘의 수행시간을 측정한다.
즉, 알고리즘의 수행시간 = 최악의 경우의 입력에 대한 기본 연산의 수행 횟수이다.
- 최악의 경우의 수행시간은 입력의 크기 n에 대한 함수 T(n)로 표기한다.
→ T(n)의 수행시간을 갖는 알고리즘은 어떠한 입력에 대해서도 T(n) 시간 이내에 종료됨을 보장한다.
- 예시
    - 다음은 가상코드로 작성된 n개의 정수중 최댓값을 찾는 알고리즘이다.
    - 해당 알고리즘에서 최악의 입력에 대한 횟수를 분석해보자.
    
    ```jsx
    algorithm arrayMax(A, n)
    input: n개의 정수를 저장한 배열 A
    output: A의 수 중에서 최대값
    currentMax = A[0] // (=) 연산자 1회
    for i = 1 to n-1 do // 최악의 경우 (n-1)회 까지 반복
    	if currentMax < A[i] // (<) 연산자 (n-1)회
    		currentMax = A[i] // (=) 연산자 (n-1)회
    return currentMax
    ```
    
    - 위의 예시에서 기본연산 수행 횟수는 (=) 연산자 1회 + (<) 연산자 n-1회 + (=) 연산자 n-1회이므로 T(n) = 2n-1이 된다.
