---
title:  "시간복잡도와 Big-O 표기법"

categories:

- Algorithm
tags:
- [Algorithm, TimeComplex]

toc: true
toc_sticky: false

## date: 2022-08-24
last_modified_at: 2022-08-24
---

<aside>
💡 본 포스트는 한국외대 컴퓨터공학부 신찬수 교수님의 자료구조 수업내용과 자료를 참조하여 작성되었습니다.

</aside>

---

## 알고리즘의 시간복잡도

- 가상 컴퓨터에서 가상언어로 작성된 가상코드(Pseudo Code)를 실행한다고 가정한다.
- 특정 입력에 대해 수행되는 알고리즘의 기본연산(primitive operation)의 횟수로 수행시간을 정의한다.
    
    > 기본연산의 종류
    - 대입연산 (=)
    - 산술연산 (+, -, *, /)
    - 비교연산 (>, ≥, <, ≤, ==, ≠)
    - 논리연산 (AND, OR, NOT)
    - 비트연산 (bit-AND, bit-OR, bit-NOT, bit-XOR, <<, >>)
    > 
- 하지만 입력의 종류가 무한하여 현실적으로 모든 기본연산 횟수의 평균을 구하는것은 불가능하기 때문에 최악의
입력(worst-case input)을 가정하여 알고리즘의 수행시간을 측정한다.
- 즉, 알고리즘의 수행시간 = 최악의 경우의 입력에 대한 기본 연산의 수행 횟수이다.
- 최악의 경우의 수행시간은 입력의 크기 n에 대한 함수 T(n)로 표기한다.
→ T(n)의 수행시간을 갖는 알고리즘은 어떠한 입력에 대해서도 T(n) 시간 이내에 종료됨을 보장한다.
- 예시
    - 다음은 가상코드로 작성된 n개의 정수중 최댓값을 찾는 알고리즘이다.
    - 해당 알고리즘에서 최악의 입력에 대한 횟수를 분석해보자.
    
    ```jsx
    algorithm arrayMax(A, n)
    input: n개의 정수를 저장한 배열 A
    output: A의 수 중에서 최대값
    currentMax = A[0] // '=' 연산자 1회
    for i = 1 to n-1 do // 최악의 경우 (n-1)회 까지 반복
    	if currentMax < A[i] // '<' 연산자 (n-1)회
    		currentMax = A[i] // '=' 연산자 (n-1)회
    return currentMax
    ```
    
    - 위의 예시에서 기본연산 수행 횟수는 '=' 연산자 1회 + '<' 연산자 n-1회 + '=' 연산자 n-1회이므로
      시간 복잡도는 T(n) = 2n-1이 된다.

## Big-O 표기법

- 위에서 본 예시처럼 최악의 입력에 대한 기본연산 횟수를 측정하는 것은 매우 까다로운 일이다.
- 정확한 횟수보다는 입력의 크기 n이 커질때 수행시간이 증가하는 정도가 훨씬 중요하다.
- 따라서 수행시간 함수 T(n)에서 함수값의 증가율이 가장 큰 항 하나로 간략하게 표현할 수 있다.
- 위의 예시 T(n) = 2n-1의 경우 상수항보다는 n의 일차항이 T(n)의 값을 결정하게 되므로 상수항을 생략해도 문제가 없다.
- 이렇게 수행시간 함수의 최고차 항만을 남기고 나머지를 생략하는 식으로 수행시간을 간략하게 표기하는 방법을 **근사적 표기법**이라 부르고 Big-O를 이용하여 표기한다.

    > Big-O 표기법
    - T(n) = 2n+5 -> O(n)
    - T(n) = 3n^2+12n-6 -> O(n^2)
    >

### Big-O 표기법의 성능비교
- Big-O 표기법에서 자주 사용되는 표기법은 아래 그래프와 같다.
![ ](/assets/images/bigO.jpeg)
- 위의 그래프에서 Big-O표기법으로 표기된 시간복잡도들의 성능을 비교하면 다음과 같다.
- 왼쪽에서 오른쪽으로 갈수록 효율성이 떨어진다.
- O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n)
- 위에 나온 시간복잡도들의 예제가 무엇인지 확인해보고 알고리즘을 공부해나가면 좋을거 같다.
    > 시간복잡도의 예제
    - O(1): 스택에서 push, pop
    - O(logn): 이진트리
    - O(n): for문
    - O(nlogn): 퀵 정렬(quick sort), 병합정렬(merge sort), 힙 정렬(heap Sort)
    - O(n^2): 이중 for 문, 삽입정렬(insertion sort), 거품정렬(bubble sort), 선택정렬(selection sort)
    - O(2^n): 피보나치 
